<!DOCTYPE HTML>
<html>
    <head>
        <link rel="Stylesheet" type="text/css" href="/static/css/style.css">
        <link rel="Stylesheet" type="text/css" href="/static/css/tango.css">
        <title>Dockerfile - Wiki | janes</title>
        <meta name="keywords" content=""/>
        <meta name="description" content=""/>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body>
        <div id="container">
            
<div id="header">
  <div id="post-nav"><a href="/">Home</a>&nbsp;»&nbsp;<a href="/#Docker">Docker</a>&nbsp;»&nbsp;Dockerfile</div>
</div>
<div class="clearfix"></div>
<div id="title">Dockerfile</div>
  <div id="content">
  <h2 id="dockerfile">Dockerfile 指令选项:</h2>
<div class="hlcode"><pre><span class="n">FROM</span>
<span class="n">MAINTAINER</span>
<span class="n">RUN</span>
<span class="n">CMD</span>
<span class="n">EXPOSE</span>
<span class="n">ENV</span>
<span class="n">ADD</span>
<span class="n">COPY</span>
<span class="n">ENTRYPOINT</span>
<span class="n">VOLUME</span>
<span class="n">USER</span>
<span class="n">WORKDIR</span>
<span class="n">ONBUILD</span>
</pre></div>


<ul>
<li>FROM </li>
</ul>
<div class="hlcode"><pre><span class="nb">FROM</span> <span class="o">&lt;</span><span class="nb">image</span><span class="o">&gt;</span>
</pre></div>


<p>FROM 指定构建镜像的基础源镜像，如果本地没有指定的镜像，则会自动从 Docker 的公共库 pull 镜像下来。</p>
<p>FROM 必须是 Dockerfile 中非注释行的第一个指令，即一个 Dockerfile 从 FROM 语句开始。</p>
<p>FROM 可以在一个 Dockerfile 中出现多次</p>
<p>如果 FROM 语句没有指定镜像标签，则默认使用 latest 标签。</p>
<ul>
<li>MAINTAINER </li>
</ul>
<div class="hlcode"><pre><span class="nx">MAINTAINER</span> <span class="o">&lt;</span><span class="nb">name</span><span class="o">&gt;</span>  <span class="o">--</span><span class="err">指定创建镜像的用户</span>
</pre></div>


<ul>
<li>EXPOSE</li>
</ul>
<div class="hlcode"><pre><span class="nb">EXPOSE</span> <span class="o">&lt;</span><span class="nb">port</span><span class="o">&gt;</span> <span class="err">[</span><span class="o">&lt;</span><span class="nb">port</span><span class="o">&gt;</span><span class="nx">...</span><span class="cp">]</span>
</pre></div>


<p>告诉 Docker 服务端容器对外映射的本地端口，需要在 docker run 的时候使用 -p 或者 -P 选项生效</p>
<ul>
<li>CMD</li>
</ul>
<p>CMD 会在启动容器的时候执行，build 时不执行，而 RUN 只是在构建镜像的时候执行，后续镜像构建完成之后，启动容器就与 RUN 无关了</p>
<ul>
<li>ENV</li>
</ul>
<div class="hlcode"><pre><span class="nb">ENV</span> <span class="o">&lt;</span><span class="nb">key</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="nb">value</span><span class="o">&gt;</span>       <span class="err">#</span> <span class="err">只能设置一个变量</span>
<span class="nb">ENV</span> <span class="o">&lt;</span><span class="nb">key</span><span class="o">&gt;=&lt;</span><span class="nb">value</span><span class="o">&gt;</span> <span class="nx">...</span>   <span class="err">#</span> <span class="err">允许一次设置多个变量</span>
</pre></div>


<p>指定一个环节变量，会被后续 RUN 指令使用，并在容器运行时保留。</p>
<p>例子:</p>
<div class="hlcode"><pre><span class="n">ENV</span> <span class="n">myName</span><span class="o">=</span><span class="s">&quot;John Doe&quot;</span> <span class="n">myDog</span><span class="o">=</span><span class="n">Rex</span><span class="err">\</span> <span class="n">The</span><span class="err">\</span> <span class="n">Dog</span> \
    <span class="n">myCat</span><span class="o">=</span><span class="n">fluffy</span>
</pre></div>


<p>等同于</p>
<div class="hlcode"><pre><span class="n">ENV</span> <span class="n">myName</span> <span class="n">John</span> <span class="n">Doe</span>
<span class="n">ENV</span> <span class="n">myDog</span> <span class="n">Rex</span> <span class="n">The</span> <span class="n">Dog</span>
<span class="n">ENV</span> <span class="n">myCat</span> <span class="n">fluffy</span>
</pre></div>


<ul>
<li>ADD</li>
</ul>
<div class="hlcode"><pre><span class="nb">ADD</span> <span class="o">&lt;</span><span class="nb">src</span><span class="o">&gt;</span><span class="nx">...</span> <span class="o">&lt;</span><span class="nx">dest</span><span class="o">&gt;</span>
</pre></div>


<p>ADD 复制本地主机文件、目录或者远程文件 URLS 从 <src> 并且添加到容器指定路径中 <dest>。</p>
<p><src> 支持通过 GO 的正则模糊匹配，具体规则可参见 Go filepath.Match</p>
<div class="hlcode"><pre><span class="n">ADD</span> <span class="n">hom</span><span class="o">*</span> <span class="o">/</span><span class="n">mydir</span><span class="o">/</span>        <span class="err">#</span> <span class="n">adds</span> <span class="n">all</span> <span class="n">files</span> <span class="n">starting</span> <span class="n">with</span> <span class="s">&quot;hom&quot;</span>
<span class="n">ADD</span> <span class="n">hom</span><span class="o">?</span><span class="p">.</span><span class="n">txt</span> <span class="o">/</span><span class="n">mydir</span><span class="o">/</span>    <span class="err">#</span> <span class="o">?</span> <span class="n">is</span> <span class="n">replaced</span> <span class="n">with</span> <span class="n">any</span> <span class="n">single</span> <span class="n">character</span>
</pre></div>


<p><dest> 路径必须是绝对路径，如果 <dest> 不存在，会自动创建对应目录
<src> 路径必须是 Dockerfile 所在路径的相对路径
<src> 如果是一个目录，只会复制目录下的内容，而目录本身则不会被复制</p>
<ul>
<li>COPY</li>
</ul>
<div class="hlcode"><pre><span class="nx">COPY</span> <span class="o">&lt;</span><span class="nb">src</span><span class="o">&gt;</span><span class="nx">...</span> <span class="o">&lt;</span><span class="nx">dest</span><span class="o">&gt;</span>
</pre></div>


<p>COPY 复制新文件或者目录从 <src> 添加到容器指定路径中 <dest>。用法同 ADD，唯一的不同是不能指定远程文件 URLS。</p>
<p>下面一条命令，会出现 ##镜像中文件层次结构错乱的情况##，暂不清楚是什么造成的，仅记之</p>
<div class="hlcode"><pre><span class="n">COPY</span> <span class="n">code</span><span class="o">/*</span> <span class="o">/</span><span class="n">root</span><span class="o">/</span><span class="n">code</span>  <span class="err">#</span> <span class="n">code</span> <span class="err">目录与</span> <span class="n">Dockerfile</span> <span class="err">位于同一级目录</span>
</pre></div>


<p>正确的格式如下：</p>
<div class="hlcode"><pre><span class="n">COPY</span> <span class="n">code</span><span class="o">/</span> <span class="o">/</span><span class="n">root</span><span class="o">/</span><span class="n">code</span><span class="o">/</span>  
</pre></div>


<ul>
<li>VOLUME</li>
</ul>
<div class="hlcode"><pre><span class="n">VOLUME</span> <span class="p">[</span><span class="s">&quot;/data&quot;</span><span class="p">]</span>
</pre></div>


<p>创建一个可以从本地主机或其他容器挂载的挂载点</p>
<ul>
<li>note</li>
</ul>
<p>1.避免使用 RUN apt-get upgrade</p>
<p>2.apt-get update 和 apt-get install 连接使用，避免缓存问题</p>
<div class="hlcode"><pre><span class="n">RUN</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">update</span> <span class="o">&amp;&amp;</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">install</span> <span class="o">-</span><span class="n">y</span> \
    <span class="n">python</span>   
</pre></div>


<p>参考：</p>
<p><a href="http://blog.opskumu.com/docker.html">docker 学习笔记</a></p>
</div>

        </div>
        <div id="footer">
            <span>
                Copyright © 2012-2016 .
                Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.
            </span>
        </div>
        
    </body>
</html>