<!DOCTYPE HTML>
<html>
    <head>
        <link rel="Stylesheet" type="text/css" href="/static/css/style.css">
        <link rel="Stylesheet" type="text/css" href="/static/css/tango.css">
        <title>Dockerfile - Wiki | janes</title>
        <meta name="keywords" content=""/>
        <meta name="description" content=""/>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body>
        <div id="container">
            
<div id="header">
  <div id="post-nav"><a href="/">Home</a>&nbsp;»&nbsp;<a href="/#Docker">Docker</a>&nbsp;»&nbsp;Dockerfile</div>
</div>
<div class="clearfix"></div>
<div id="title">Dockerfile</div>
  <div id="content">
  <h2 id="dockerfile">Dockerfile 指令选项:</h2>
<div class="hlcode"><pre>FROM
MAINTAINER
RUN
CMD
EXPOSE
ENV
ADD
COPY
ENTRYPOINT
VOLUME
USER
WORKDIR
ONBUILD
</pre></div>


<ul>
<li>FROM </li>
</ul>
<div class="hlcode"><pre>FROM &lt;image&gt;
</pre></div>


<p>FROM 指定构建镜像的基础源镜像，如果本地没有指定的镜像，则会自动从 Docker 的公共库 pull 镜像下来。</p>
<p>FROM 必须是 Dockerfile 中非注释行的第一个指令，即一个 Dockerfile 从 FROM 语句开始。</p>
<p>FROM 可以在一个 Dockerfile 中出现多次</p>
<p>如果 FROM 语句没有指定镜像标签，则默认使用 latest 标签。</p>
<ul>
<li>MAINTAINER </li>
</ul>
<div class="hlcode"><pre>MAINTAINER &lt;name&gt;  --指定创建镜像的用户
</pre></div>


<ul>
<li>EXPOSE</li>
</ul>
<div class="hlcode"><pre>EXPOSE &lt;port&gt; [&lt;port&gt;...]
</pre></div>


<p>告诉 Docker 服务端容器对外映射的本地端口，需要在 docker run 的时候使用 -p 或者 -P 选项生效</p>
<ul>
<li>CMD</li>
</ul>
<p>CMD 会在启动容器的时候执行，build 时不执行，而 RUN 只是在构建镜像的时候执行，后续镜像构建完成之后，启动容器就与 RUN 无关了</p>
<ul>
<li>ENV</li>
</ul>
<div class="hlcode"><pre>ENV &lt;key&gt; &lt;value&gt;       # 只能设置一个变量
ENV &lt;key&gt;=&lt;value&gt; ...   # 允许一次设置多个变量
</pre></div>


<p>指定一个环节变量，会被后续 RUN 指令使用，并在容器运行时保留。</p>
<p>例子:</p>
<div class="hlcode"><pre>ENV myName=&quot;John Doe&quot; myDog=Rex\ The\ Dog \
    myCat=fluffy
</pre></div>


<p>等同于</p>
<div class="hlcode"><pre>ENV myName John Doe
ENV myDog Rex The Dog
ENV myCat fluffy
</pre></div>


<ul>
<li>USER</li>
</ul>
<p>使用哪个用户跑container</p>
<ul>
<li>ADD</li>
</ul>
<div class="hlcode"><pre>ADD &lt;src&gt;... &lt;dest&gt;
</pre></div>


<p>ADD 复制本地主机文件、目录或者远程文件 URLS 从 <src> 并且添加到容器指定路径中 <dest>。</p>
<p><src> 支持通过 GO 的正则模糊匹配，具体规则可参见 Go filepath.Match</p>
<div class="hlcode"><pre>ADD hom* /mydir/        # adds all files starting with &quot;hom&quot;
ADD hom?.txt /mydir/    # ? is replaced with any single character
</pre></div>


<p><dest> 路径必须是绝对路径，如果 <dest> 不存在，会自动创建对应目录
<src> 路径必须是 Dockerfile 所在路径的相对路径
<src> 如果是一个目录，只会复制目录下的内容，而目录本身则不会被复制</p>
<p>注:</p>
<blockquote>
<p>所有拷贝到container中的文件和文件夹权限, 和原文件权限保持一致？？？</p>
</blockquote>
<ul>
<li>COPY</li>
</ul>
<div class="hlcode"><pre>COPY &lt;src&gt;... &lt;dest&gt;
</pre></div>


<p>COPY 复制新文件或者目录从 <src> 添加到容器指定路径中 <dest>。用法同 ADD，唯一的不同是不能指定远程文件 URLS。</p>
<p>下面一条命令，会出现 ##镜像中文件层次结构错乱的情况##，暂不清楚是什么造成的，仅记之</p>
<div class="hlcode"><pre>COPY code/* /root/code  # code 目录与 Dockerfile 位于同一级目录
</pre></div>


<p>正确的格式如下：</p>
<div class="hlcode"><pre>COPY code/ /root/code/  
</pre></div>


<ul>
<li>VOLUME</li>
</ul>
<div class="hlcode"><pre># 在容器内新建 /data 目录
VOLUME [&quot;/data&quot;]
</pre></div>


<p>VOLUME指令用来在容器中设置一个挂载点，可以用来让主机或其他容器挂载，以实现数据共享或对容器数据的备份、恢复或迁移</p>
<h2 id="note">note</h2>
<ul>
<li>1.避免使用 RUN apt-get upgrade</li>
</ul>
<p>这样会打乱镜像中包的依赖，可能会出现问题</p>
<ul>
<li>2.apt-get update 和 apt-get install 连接使用，避免缓存问题</li>
</ul>
<div class="hlcode"><pre>RUN apt-get update &amp;&amp; apt-get install -y \
    python   
</pre></div>


<ul>
<li>3.COPY vs ADD</li>
</ul>
<p>ADD 比 COPY 多了2个功能--下载URL和解压，其他一样</p>
<p>如果不希望压缩文件拷贝到container后会被解压，则使用COPY
如果需要自动下载URL并拷贝到container，则使用ADD</p>
<p>参考：</p>
<p><a href="http://blog.opskumu.com/docker.html">docker 学习笔记</a></p>
</div>

        </div>
        <div id="footer">
            <span>
                Copyright © 2012-2016 .
                Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.
            </span>
        </div>
        
    </body>
</html>