<!DOCTYPE HTML>
<html>
    <head>
        <link rel="Stylesheet" type="text/css" href="/static/css/style.css">
        <link rel="Stylesheet" type="text/css" href="/static/css/tango.css">
        <title>PHP序列化 - Wiki | janes</title>
        <meta name="keywords" content=""/>
        <meta name="description" content=""/>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body>
        <div id="container">
            
<div id="header">
  <div id="post-nav"><a href="/">Home</a>&nbsp;»&nbsp;<a href="/#WebSecurity">WebSecurity</a>&nbsp;»&nbsp;PHP序列化</div>
</div>
<div class="clearfix"></div>
<div id="title">PHP序列化</div>
  <div id="content">
  <h2 id="_1">序列化机制</h2>
<p>PHP中的配置文件php.ini中含有几项配置项</p>
<div class="hlcode"><pre><span class="n">session</span><span class="p">.</span><span class="n">save_path</span><span class="o">=</span><span class="s">&quot;&quot;</span>   <span class="o">--</span><span class="err">设置</span><span class="n">session</span><span class="err">的存储路径</span>
<span class="n">session_set_save_handler</span><span class="o">=</span><span class="s">&quot;&quot;</span> <span class="o">--</span><span class="err">设定用户自定义存储函数，如果想使用</span><span class="n">PHP</span><span class="err">内置会话存储机制之外的可以使用本函数</span><span class="p">(</span><span class="err">数据库等方式</span><span class="p">)</span>
<span class="n">session</span><span class="p">.</span><span class="n">auto_start</span>   <span class="n">boolen</span> <span class="o">--</span><span class="err">指定会话模块是否在请求开始时启动一个会话</span><span class="p">,</span><span class="err">默认为</span><span class="mi">0</span><span class="err">不启动</span>
<span class="n">session</span><span class="p">.</span><span class="n">serialize_handler</span>   <span class="n">string</span> <span class="o">--</span><span class="err">定义用来序列化</span><span class="o">/</span><span class="err">反序列化的处理器名字。默认使用</span><span class="n">php</span>
</pre></div>


<blockquote>
<p>当session.auto_start设置为True的时候或者手动session_start()创建新会话，PHP内部调会调用会话管理器。</p>
</blockquote>
<h2 id="php-session">PHP Session 三种序列化方式</h2>
<p>PHP 内置了多种处理器用于存取 $_SESSION 数据时会对数据进行序列化和反序列化，常用的有以下三种，对应三种不同的处理格式：</p>
<table>
<thead>
<tr>
<th>处理器</th>
<th>对应的存储格式</th>
</tr>
</thead>
<tbody>
<tr>
<td>php</td>
<td>键名 ＋ 竖线 ＋ 经过 serialize() 函数反序列处理的值</td>
</tr>
<tr>
<td>php_binary</td>
<td>键名的长度对应的 ASCII 字符 ＋ 键名 ＋ 经过 serialize() 函数反序列处理的值</td>
</tr>
<tr>
<td>php_serialize <br>(php&gt;=5.5.4)</td>
<td>经过 serialize() 函数反序列处理的数组</td>
</tr>
</tbody>
</table>
<p>php处理器序列化过的值</p>
<div class="hlcode"><pre><span class="n">name</span><span class="o">|</span><span class="n">s</span><span class="o">:</span><span class="mi">6</span><span class="o">:</span><span class="s">&quot;whoami&quot;</span><span class="p">;</span><span class="n">address</span><span class="o">|</span><span class="n">s</span><span class="o">:</span><span class="mi">7</span><span class="o">:</span><span class="s">&quot;beijing&quot;</span><span class="p">;</span>

<span class="cp"># 其中每个session值是以&quot;;&quot;分割开来，例如</span>
<span class="n">name</span><span class="o">|</span><span class="n">s</span><span class="o">:</span><span class="mi">6</span><span class="o">:</span><span class="s">&quot;whoami&quot;</span><span class="p">;</span>
</pre></div>


<p>session值,"|"前面表示session名称，"|"后边表示session具体信息,包含数据类型,长度,数据内容。</p>
<h3 id="sessionserialize_handler">配置选项 session.serialize_handler</h3>
<p>PHP 提供了 session.serialize_handler 配置选项，通过该选项可以设置序列化及反序列化时使用的处理器：</p>
<div class="hlcode"><pre><span class="x">session.serialize_handler   &quot;php&quot;   PHP_INI_ALL</span>
</pre></div>


<h3 id="_2">安全隐患</h3>
<p>通过上面对存储格式的分析，如果 PHP 在反序列化存储的 $_SESSION 数据时的使用的处理器和序列化时使用的处理器不同，会导致数据无法正确反序列化，通过特殊的构造，甚至可以伪造任意数据：）</p>
<div class="hlcode"><pre><span class="x">$_SESSION[&#39;ryat&#39;] = &#39;|O:8:&quot;stdClass&quot;:0:{}&#39;;</span>
</pre></div>


<p>例如上面的 $_SESSION 数据，在存储时使用的序列化处理器为 php_serialize，存储的格式如下：</p>
<div class="hlcode"><pre><span class="x">a:1:{s:4:&quot;ryat&quot;;s:20:&quot;|O:8:&quot;stdClass&quot;:0:{}&quot;;}</span>
</pre></div>


<p>在读取数据时如果用的反序列化处理器不是 php_serialize，而是 php 的话，那么反序列化后的数据将会变成：</p>
<div class="hlcode"><pre><span class="x">// var_dump($_SESSION);</span>
<span class="x">array(1) {</span>
<span class="x">  [&quot;a:1:{s:4:&quot;ryat&quot;;s:20:&quot;&quot;]=&gt;</span>
<span class="x">  object(stdClass)#1 (0) {</span>
<span class="x">  }</span>
<span class="x">}</span>
</pre></div>


<p>可以看到，通过注入 <code>|</code> 字符伪造了对象的序列化数据，成功实例化了 stdClass 对象：）</p>
<h3 id="_3">实际利用</h3>
<h4 id="i-sessionauto_starton">i）当 session.auto_start＝On 时：</h4>
<p>当配置选项 session.auto_start＝On，会自动注册 Session 会话，因为该过程是发生在脚本代码执行前，所以在脚本中设定的包括序列化处理器在内的 session 相关配选项的设置是不起作用的，因此一些需要在脚本中设置序列化处理器配置的程序会在 session.auto_start＝On 时，销毁自动生成的 Session 会话，然后设置需要的序列化处理器，再调用 session_start() 函数注册会话，这时如果脚本中设置的序列化处理器与 php.ini 中设置的不同，就会出现安全问题，如下面的代码：</p>
<div class="hlcode"><pre><span class="x">//foo.php</span>

<span class="x">if (ini_get(&#39;session.auto_start&#39;)) {</span>
<span class="x">    session_destroy();</span>
<span class="x">}</span>

<span class="x">ini_set(&#39;session.serialize_handler&#39;, &#39;php_serialize&#39;);</span>
<span class="x">session_start();</span>

<span class="x">$_SESSION[&#39;ryat&#39;] = $_GET[&#39;ryat&#39;];</span>
</pre></div>


<p>当第一次访问该脚本，并提交数据如下：</p>
<div class="hlcode"><pre><span class="x">foo.php?ryat=|O:8:&quot;stdClass&quot;:0:{}</span>
</pre></div>


<p>脚本会按照 php_serialize 处理器的序列化格式存储数据：</p>
<div class="hlcode"><pre><span class="x">a:1:{s:4:&quot;ryat&quot;;s:20:&quot;|O:8:&quot;stdClass&quot;:0:{}&quot;;}</span>
</pre></div>


<p>当第二次访问该脚本时，PHP 会按照 php.ini 里设置的序列化处理器反序列化存储的数据，这时如果 php.ini 里设置的是 php 处理器的话，将会反序列化伪造的数据，成功实例化了 stdClass 对象：）</p>
<p>这里需要注意的是，因为 PHP 自动注册 Session 会话是在脚本执行前，所以通过该方式只能注入 PHP 的内置类。</p>
<h4 id="ii-sessionauto_startoff">ii）当 session.auto_start＝Off 时：</h4>
<p>当配置选项 session.auto_start＝Off，两个脚本注册 Session 会话时使用的序列化处理器不同，就会出现安全问题，如下面的代码：</p>
<div class="hlcode"><pre><span class="x">//foo1.php</span>

<span class="x">ini_set(&#39;session.serialize_handler&#39;, &#39;php_serialize&#39;);</span>
<span class="x">session_start();</span>

<span class="x">$_SESSION[&#39;ryat&#39;] = $_GET[&#39;ryat&#39;];</span>

<span class="x">//foo2.php</span>

<span class="x">ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;);</span>
<span class="x">//or session.serialize_handler set to php in php.ini </span>
<span class="x">session_start();</span>

<span class="x">class ryat {</span>
<span class="x">    var $hi;</span>

<span class="x">    function __wakeup() {</span>
<span class="x">        echo &#39;hi&#39;;</span>
<span class="x">    }</span>
<span class="x">    function __destruct() {</span>
<span class="x">        echo $this-&gt;hi;</span>
<span class="x">    }</span>
<span class="x">}</span>
</pre></div>


<p>当访问 foo1.php 时，提交数据如下：</p>
<div class="hlcode"><pre><span class="x">foo1.php?ryat=|O:4:&quot;ryat&quot;:1:{s:2:&quot;hi&quot;;s:4:&quot;ryat&quot;;}</span>
</pre></div>


<p>脚本会按照 php_serialize 处理器的序列化格式存储数据，访问 foo2.php 时，则会按照 php 处理器的反序列化格式读取数据，这时将会反序列化伪造的数据，成功实例化了 ryat 对象，并将会执行类中的 __wakeup 方法和 __destruct 方法：）</p>
</div>

        </div>
        <div id="footer">
            <span>
                Copyright © 2012-2016 .
                Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.
            </span>
        </div>
        
    </body>
</html>